{
  "language": "Solidity",
  "sources": {
    "contracts/tests/NFTs-ETH/CryptoPunksMarket.sol": {
      "content": "\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.11;\r\n\r\ncontract CryptoPunksMarket {\r\n\r\n    // You can use this hash to verify the image file containing all the punks\r\n    string public imageHash = \"ac39af4793119ee46bbff351d8cb6b5f23da60222126add4268e261199a2921b\";\r\n\r\n    address owner;\r\n\r\n    string public standard = 'CryptoPunks';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    uint public nextPunkIndexToAssign = 0;\r\n\r\n    bool public allPunksAssigned = false;\r\n    uint public punksRemainingToAssign = 0;\r\n\r\n    //mapping (address => uint) public addressToPunkIndex;\r\n    mapping (uint => address) public punkIndexToAddress;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    struct Offer {\r\n        bool isForSale;\r\n        uint punkIndex;\r\n        address seller;\r\n        uint minValue;          // in ether\r\n        address onlySellTo;     // specify to sell only to a specific person\r\n    }\r\n\r\n    struct Bid {\r\n        bool hasBid;\r\n        uint punkIndex;\r\n        address bidder;\r\n        uint value;\r\n    }\r\n\r\n    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person\r\n    mapping (uint => Offer) public punksOfferedForSale;\r\n\r\n    // A record of the highest punk bid\r\n    mapping (uint => Bid) public punkBids;\r\n\r\n    mapping (address => uint) public pendingWithdrawals;\r\n\r\n    event Assign(address indexed to, uint256 punkIndex);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);\r\n    event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);\r\n    event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);\r\n    event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);\r\n    event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);\r\n    event PunkNoLongerForSale(uint indexed punkIndex);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function CryptoPunksMarket() payable {\r\n        //        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\r\n        owner = msg.sender;\r\n        totalSupply = 10000;                        // Update total supply\r\n        punksRemainingToAssign = totalSupply;\r\n        name = \"CRYPTOPUNKS\";                                   // Set the name for display purposes\r\n        symbol = \"Ï¾\";                               // Set the symbol for display purposes\r\n        decimals = 0;                                       // Amount of decimals for display purposes\r\n    }\r\n\r\n    function setInitialOwner(address to, uint punkIndex) {\r\n        if (msg.sender != owner) throw;\r\n        if (allPunksAssigned) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        if (punkIndexToAddress[punkIndex] != to) {\r\n            if (punkIndexToAddress[punkIndex] != 0x0) {\r\n                balanceOf[punkIndexToAddress[punkIndex]]--;\r\n            } else {\r\n                punksRemainingToAssign--;\r\n            }\r\n            punkIndexToAddress[punkIndex] = to;\r\n            balanceOf[to]++;\r\n            Assign(to, punkIndex);\r\n        }\r\n    }\r\n\r\n    function setInitialOwners(address[] addresses, uint[] indices) {\r\n        if (msg.sender != owner) throw;\r\n        uint n = addresses.length;\r\n        for (uint i = 0; i < n; i++) {\r\n            setInitialOwner(addresses[i], indices[i]);\r\n        }\r\n    }\r\n\r\n    function allInitialOwnersAssigned() {\r\n        if (msg.sender != owner) throw;\r\n        allPunksAssigned = true;\r\n    }\r\n\r\n    function getPunk(uint punkIndex) {\r\n        if (!allPunksAssigned) throw;\r\n        if (punksRemainingToAssign == 0) throw;\r\n        if (punkIndexToAddress[punkIndex] != 0x0) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        punkIndexToAddress[punkIndex] = msg.sender;\r\n        balanceOf[msg.sender]++;\r\n        punksRemainingToAssign--;\r\n        Assign(msg.sender, punkIndex);\r\n    }\r\n\r\n    // Transfer ownership of a punk to another user without requiring payment\r\n    function transferPunk(address to, uint punkIndex) {\r\n        if (!allPunksAssigned) throw;\r\n        if (punkIndexToAddress[punkIndex] != msg.sender) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        if (punksOfferedForSale[punkIndex].isForSale) {\r\n            punkNoLongerForSale(punkIndex);\r\n        }\r\n        punkIndexToAddress[punkIndex] = to;\r\n        balanceOf[msg.sender]--;\r\n        balanceOf[to]++;\r\n        Transfer(msg.sender, to, 1);\r\n        PunkTransfer(msg.sender, to, punkIndex);\r\n        // Check for the case where there is a bid from the new owner and refund it.\r\n        // Any other bid can stay in place.\r\n        Bid bid = punkBids[punkIndex];\r\n        if (bid.bidder == to) {\r\n            // Kill bid and refund value\r\n            pendingWithdrawals[to] += bid.value;\r\n            punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);\r\n        }\r\n    }\r\n\r\n    function punkNoLongerForSale(uint punkIndex) {\r\n        if (!allPunksAssigned) throw;\r\n        if (punkIndexToAddress[punkIndex] != msg.sender) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, msg.sender, 0, 0x0);\r\n        PunkNoLongerForSale(punkIndex);\r\n    }\r\n\r\n    function offerPunkForSale(uint punkIndex, uint minSalePriceInWei) {\r\n        if (!allPunksAssigned) throw;\r\n        if (punkIndexToAddress[punkIndex] != msg.sender) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, 0x0);\r\n        PunkOffered(punkIndex, minSalePriceInWei, 0x0);\r\n    }\r\n\r\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) {\r\n        if (!allPunksAssigned) throw;\r\n        if (punkIndexToAddress[punkIndex] != msg.sender) throw;\r\n        if (punkIndex >= 10000) throw;\r\n        punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, toAddress);\r\n        PunkOffered(punkIndex, minSalePriceInWei, toAddress);\r\n    }\r\n\r\n    function buyPunk(uint punkIndex) payable {\r\n        if (!allPunksAssigned) throw;\r\n        Offer offer = punksOfferedForSale[punkIndex];\r\n        if (punkIndex >= 10000) throw;\r\n        if (!offer.isForSale) throw;                // punk not actually for sale\r\n        if (offer.onlySellTo != 0x0 && offer.onlySellTo != msg.sender) throw;  // punk not supposed to be sold to this user\r\n        if (msg.value < offer.minValue) throw;      // Didn't send enough ETH\r\n        if (offer.seller != punkIndexToAddress[punkIndex]) throw; // Seller no longer owner of punk\r\n\r\n        address seller = offer.seller;\r\n\r\n        punkIndexToAddress[punkIndex] = msg.sender;\r\n        balanceOf[seller]--;\r\n        balanceOf[msg.sender]++;\r\n        Transfer(seller, msg.sender, 1);\r\n\r\n        punkNoLongerForSale(punkIndex);\r\n        pendingWithdrawals[seller] += msg.value;\r\n        PunkBought(punkIndex, msg.value, seller, msg.sender);\r\n\r\n        // Check for the case where there is a bid from the new owner and refund it.\r\n        // Any other bid can stay in place.\r\n        Bid bid = punkBids[punkIndex];\r\n        if (bid.bidder == msg.sender) {\r\n            // Kill bid and refund value\r\n            pendingWithdrawals[msg.sender] += bid.value;\r\n            punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);\r\n        }\r\n    }\r\n\r\n    function withdraw() {\r\n        if (!allPunksAssigned) throw;\r\n        uint amount = pendingWithdrawals[msg.sender];\r\n        // Remember to zero the pending refund before\r\n        // sending to prevent re-entrancy attacks\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function enterBidForPunk(uint punkIndex) payable {\r\n        if (punkIndex >= 10000) throw;\r\n        if (!allPunksAssigned) throw;                \r\n        if (punkIndexToAddress[punkIndex] == 0x0) throw;\r\n        if (punkIndexToAddress[punkIndex] == msg.sender) throw;\r\n        if (msg.value == 0) throw;\r\n        Bid existing = punkBids[punkIndex];\r\n        if (msg.value <= existing.value) throw;\r\n        if (existing.value > 0) {\r\n            // Refund the failing bid\r\n            pendingWithdrawals[existing.bidder] += existing.value;\r\n        }\r\n        punkBids[punkIndex] = Bid(true, punkIndex, msg.sender, msg.value);\r\n        PunkBidEntered(punkIndex, msg.value, msg.sender);\r\n    }\r\n\r\n    function acceptBidForPunk(uint punkIndex, uint minPrice) {\r\n        if (punkIndex >= 10000) throw;\r\n        if (!allPunksAssigned) throw;                \r\n        if (punkIndexToAddress[punkIndex] != msg.sender) throw;\r\n        address seller = msg.sender;\r\n        Bid bid = punkBids[punkIndex];\r\n        if (bid.value == 0) throw;\r\n        if (bid.value < minPrice) throw;\r\n\r\n        punkIndexToAddress[punkIndex] = bid.bidder;\r\n        balanceOf[seller]--;\r\n        balanceOf[bid.bidder]++;\r\n        Transfer(seller, bid.bidder, 1);\r\n\r\n        punksOfferedForSale[punkIndex] = Offer(false, punkIndex, bid.bidder, 0, 0x0);\r\n        uint amount = bid.value;\r\n        punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);\r\n        pendingWithdrawals[seller] += amount;\r\n        PunkBought(punkIndex, bid.value, seller, bid.bidder);\r\n    }\r\n\r\n    function withdrawBidForPunk(uint punkIndex) {\r\n        if (punkIndex >= 10000) throw;\r\n        if (!allPunksAssigned) throw;                \r\n        if (punkIndexToAddress[punkIndex] == 0x0) throw;\r\n        if (punkIndexToAddress[punkIndex] == msg.sender) throw;\r\n        Bid bid = punkBids[punkIndex];\r\n        if (bid.bidder != msg.sender) throw;\r\n        PunkBidWithdrawn(punkIndex, bid.value, msg.sender);\r\n        uint amount = bid.value;\r\n        punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);\r\n        // Refund the bid money\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}